#!/bin/bash

# Work on one Integrated Hydrological Unit using method
# from tutorial. Begin with headwater-based one (Ettrick
# Water, 332 G_NAME="Tweed (Source to Ettrick Water)") for
# simplicity.

# Extract out Ettrick Water IHU
v.extract input=wader_ihu_groups output=ihu_target where="cat = 292" --overwrite
# Clip out rivers
v.clip input=tweed_rivers clip=ihu_target output=ihu_rivers --overwrite

# Coords just downstream of NRFA 12 (21007)
# Use d.where | awk '{printf "%f\%f\point\n", $1, $2}' | v.in.ascii ...
# if using a d.mon screen
#
echo "348577.63|631535.35|point" | v.in.ascii input=- output=ihu_outlet columns='x double precision, y double precision, label varchar(20)' --overwrite
# Create stub to rivers and extend
v.db.addcolumn map=ihu_outlet columns="to_cat int"
v.distance from=ihu_outlet to=ihu_rivers output=ihu_outlet_to_rivers upload=cat column=to_cat --overwrite
# IMPORTANT. Due to a bug in GRASS #1408 the v.distance line does not work correctly. You
# must manually 
# Extract end node of connecting line
# db.droptable -f table=ihu_outlet_to_rivers
# v.db.addtable map=ihu_outlet_to_rivers
# v.to.points input=ihu_outlet_to_rivers layer=-1 use=end output=ihu_outlet_snapped_end --overwrite
# Change category numer from 2 to 1
# v.category input=ihu_outlet_snapped_end option=chlayer layer=2,1 output=ihu_outlet_snapped --overwrite


# Now we need to break the main stream network where are stub joins
# Read the stream category at the outlet.
v.db.select map=ihu_outlet columns=to_cat

# That is 10952 in the ihu_rivers vector.
# Create a new vector that contains the end node of this stream feature.
# Again, seems to be a bug in that v.segment does not create end point
# echo P 1 10952 100% | v.segment input=ihu_rivers output=ihu_stream_end --overwrite
# CLUNKY workaround
g.region vect=ihu_outlet_to_rivers
v.in.region output=tmp_region --overwrite
g.region vect=ihu_streams
v.buffer input=tmp_region output=tmp_region_buffer distance=10 --overwrite
v.clip input=ihu_streams clip=tmp_region_buffer output=ihu_streams_clip --overwrite
v.to.points input=ihu_streams_clip use=end output=ihu_stream_end --overwrite
v.to.points input=ihu_streams_clip use=start output=ihu_stream_end2 --overwrite


# Read the coordinates of the snapped outlet.
v.to.db -p map=ihu_outlet_snapped option=coor
# The outlet is at 348574.161543829|631541.683702573 
# Make a copy of ihu_rivers and break the stream at the outlet.
g.copy vector=ihu_rivers,ihu_streams --overwrite
v.edit map=ihu_streams tool=break coor=348574.161543829,631541.683702573

# We now read the coordinates at the stream end and break it off
# v.to.db -p map=ihu_stream_end option=coor
v.to.db -p map=ihu_stream_end2 option=coor
# The coordiates are 348564.16154383|631536.207512097. Delete the downstream
# piece of the stream. This edit will delete more features at the downstream
# side of the watershed, but that should be fine because we are only concerned
# with the upstream part of the stream network.
# NOTE: original version does not have id number in. This is needed as the cat
# number is not changed by the v.edit break earlier.
v.edit map=ihu_streams tool=delete id=1390 coords=348564.16154383,631536.207512097

# Above process leaves two short detached bits of stream, but shouldn't be
# a problem as downstream of outlet.

# Compute weakly connected components in the stream network and find the
# component ID inside the watershed. For querying the component ID, use the
# coordinates of the snapped outlet.
v.net.components input=ihu_streams output=ihu_streams_net method=weak --overwrite
# Coords from ihu_outlet_snapped above 
v.what -ag map=ihu_streams_net coordinates=348574.161543829,631541.683702573| grep comp=

# The component ID of the stream network inside the watershed is 1. Extract
# this stream network.
v.extract input=ihu_streams_net where=comp=1 output=ihu_streams_watershed --overwrite

# Not sure if next is needed given good DEM (in theory) so comment out for now

# Letâ€™s set the computational region that is big enough to contain the watershed.
# A buffer of 5,000 metres (100 times the 50m resolution) is used.
# g.region -a vector=ihu_streams_watershed n=n+5000 s=s-5000 e=e+5000 w=w-5000
g.region -a vector=ihu_streams_watershed
# Check region with g.region -p as some strange rounding errors
# Clip CEH DEM to computational region
r.mapcalc expression=ihu_dem=ceh_ihdtm_50m --overwrite

# Burn the stream network into the DEM and calculate flow directions. Unlike
# some other flow direction tools, r.watershed does not require sinks to be
# filled because it uses a least-cost algorithm.
v.to.rast input=ihu_streams_watershed output=ihu_streams_watershed use=val
r.mapcalc expression="ihu_dem_burned=if(isnull(ihu_streams_watershed),ihu_dem,-9999)"
#r.watershed elevation=ihu_dem_burned drainage=ihu_fdir stream=ihu_watershed_streams threshold=10 --overwrite
r.watershed -s elevation=ihu_dem_burned drainage=ihu_fdir accumulation=ihu_facc direction=ihu_direction stream=ihu_watershed_streams threshold=25 --overwrite

# Now we can delineate the watershed and display the longest flow path
# Note: r.accumulate may neet to be installed with g.extension
# r.accumulate direction=ihu_fdir outlet=ihu_outlet_snapped subwatershed=ihu_watershed accumulation=ihu_facc longest_flow_path=ihu_lfp --overwrite
# Completely stuffs up as 50m misalignment
#echo "1|348275|631375|outlet" > ihu_output2.txt
#cat ihu_output2.txt | v.in.ascii in=- out=ihu_outlet2 x=2 y=3 cat=1 columns='cat int, x double precision, y double precision, label varchar(20)' --overwrite
#r.accumulate direction=ihu_fdir outlet=ihu_outlet2 subwatershed=ihu_watershed accumulation=ihu_facc longest_flow_path=ihu_lfp --overwrite
r.accumulate direction=ihu_fdir subwatershed=ihu_watershed longest_flow_path=ihu_lfp coordinates=347825,630875 --overwrite

# Convert the watershed raster to vector.
r.to.vect input=watershed type=area output=watershed










